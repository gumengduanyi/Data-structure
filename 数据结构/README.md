# 哈夫曼编码实现说明（Huffman 编码/解码）

## 概览

该实现是一个基于 C 的命令行 Huffman 压缩/解压器（位级 I/O），采用两遍（two-pass）流式压缩：
- 第 1 遍：扫描输入，统计每个字节（0..255）出现的频率。
- 构建 Huffman 树并为每个出现的符号生成编码（code, length）。
- 第 2 遍：重新扫描输入，用生成的变长比特串替换每个字节并按位写入输出文件。

实现目标：正确、可移植、可读。为了跨平台可读写，头部字段以小端（little-endian）格式显式写入/读取。

## 文件格式（当前实现）

文件头（按顺序）：

- 魔数（4 字节）：例如 `"HUF1"`，用于快速校验文件类型。
- 原始长度（8 字节，u64，小端）：未压缩的总字节数，解码时用来停止解码。
- 频率表（256 × u64，小端）：对 256 个字节符号写入其频率（每项 8 字节），共 2048 字节。

随后是按位写入的编码比特流（LSB-first 约定）：编码的第 0 位写入字节的最低有效位，以此类推，满 8 位写出一个字节，末尾 flush 残余位（高位填 0）。

头部大小约为 4 + 8 + 2048 = 2060 字节（不含比特流）。该格式简单且便于恢复树，但对小文件头开销较大。

## 核心算法要点

- 频率计数：`uint64_t freq[256]`。
- 建树：把所有频率 > 0 的符号作为叶节点放入最小堆（MinHeap），反复弹出两个最小频率节点合并成新节点并入堆，直到只剩根节点。
- 生成编码：从根进行递归遍历，左分支记 `0`，右分支记 `1`（或按照实现约定），得到每个符号的 `(code, length)`。实现里以 LSB-first 的内部表示存储 code（即低位为先写出的比特）。
- 位级 I/O：使用 `BitWriter` 和 `BitReader` 缓冲位，减少系统调用；保持 LSB-first 的约定以配合编码表示。
- 解码：读取头部重建频率表与树，使用 `BitReader` 逐位读取并在树上游走，遇叶节点输出符号，直到输出字节数达到原始长度为止。

## 使用方法（示例）

在 `数据结构/` 目录下：

```bash
# 编译（在 macOS zsh 下示例）
gcc -x c -O2 -std=c11 哈夫曼编码解码.cpp -o huffman

# 压缩
./huffman -c 输入文件 输出.huf

# 解压
./huffman -d 输出.huf 恢复文件

# 验证
diff -u 输入文件 恢复文件
```

若 `diff` 无输出则表示压缩→解压无误。

## 实现权衡与后续改进建议

- 头部大小：当前实现固定写入 256 个 `u64`（2048 字节），对小文件不友好。改进：只写出现过的符号及其频率（紧凑头部），需要在头部先写出现符号个数并按对写入（符号 + 频率）。
- 单遍/流式：当前为两遍实现；如需单遍压缩可考虑动态/自适应 Huffman，但复杂度显著增加。
- 库化：把全局状态封装为 `HuffmanCtx`，便于重入、并行与作为库被调用（实现中可做为选项 B）。
- 统计选项：恢复或添加 `-s` 选项显示原始大小、压缩后大小、压缩比、平均码长等（实现简单，建议优先）。

## 错误与健壮性

- 已在关键 I/O 与内存分配点加入基础错误检查，但可以进一步强化：友好错误信息、异常路径的资源回收、并发安全检查（若做并行/库化）。

## 其他备注

- 字节序：当前已显式用小端序写入 u64，并在读取时按小端解析，已在同仓库中实现对应的读写函数，确保跨主机可读（前提是读写代码都使用相同的解/写实现）。
- 编码约定：实现采用 LSB-first 的比特写入/读取约定，解码端必须使用相同约定。

---

如果你要我把 README 扩展成英文版、或把“只写出现符号的紧凑头部”作为补丁实现并同时保留兼容性（例如通过头部标志位指示是否使用紧凑头），我可以继续实现并提交补丁与测试脚本。