# 哈夫曼编码/解码 代码说明

**概览**
- **文件**: `数据结构/哈夫曼编码解码.cpp`
- **目的**: 实现哈夫曼编码与解码（C 语言风格，兼容 C/C++ 编译），支持按文件压缩与解压。
- **已完成**: 源码中已添加注释；本说明将按模块逐段解释代码逻辑，并给出编译/回环测试命令。

**构建与测试**
- **编译命令**:
```bash
cd /Users/chenrong/编程/my_project/数据结构
gcc -x c -O2 -std=c11 哈夫曼编码解码.cpp -o huffman
```

## 已实现的改动

- 已实现方案 A：统一头部为 little-endian 字节序。
  - 在 `哈夫曼编码解码.cpp` 中添加了 `write_u64_le` 与 `read_u64_le` 两个辅助函数。
  - 已将写/读 `orig_size` 与频率表的 `fwrite`/`fread` 替换为上述固定字节序的函数，写入/读取均做了错误检查。
  - 在本地进行了压缩→解压的回环测试（示例输入："Hello Huffman Huffman Huffman"），输出与原文一致。

测试命令（复现）：
```bash
cd /Users/chenrong/编程/my_project/数据结构
gcc -x c -O2 -std=c11 哈夫曼编码解码.cpp -o huffman
printf "Hello Huffman Huffman Huffman" > /tmp/test_in.txt
./huffman -c /tmp/test_in.txt /tmp/test.huf
./huffman -d /tmp/test.huf /tmp/test_out.txt
diff -u /tmp/test_in.txt /tmp/test_out.txt
```

如果你同意，我将继续按你选择实现后续方案（例如 B 或 D）。
- **回环测试**（压缩->解压->比较）:
```bash
printf "Hello Huffman Huffman Huffman" > /tmp/test_in.txt
./huffman -c /tmp/test_in.txt /tmp/test.huf
./huffman -d /tmp/test.huf /tmp/test_out.txt
diff -u /tmp/test_in.txt /tmp/test_out.txt
```

**文件头与宏**
- **`#include`**: 使用了 `stdio.h`、`stdlib.h`、`string.h`、`stdint.h` 来提供文件 IO、内存管理、字符串函数和固定宽度整数类型。
- **`#define MAGIC "HUF1"`**: 压缩文件的魔数（4 字节），用于在解压时验证文件格式。

**主要数据结构**
- **`HNode`**: 哈夫曼树节点，字段：`unsigned char ch`（字节值）、`uint64_t freq`（频率）、`struct HNode *l, *r`（左右子节点）。
- **`MinHeap`**: 简单的最小堆用于构建树，包含 `HNode **data`（指针数组）、`size`、`cap`。

**函数逐段解释（关键函数）**

**`node_create`**
- 分配并初始化一个 `HNode`，设置字符、频率和左右指针为 `NULL`。失败返回 `NULL`。

**`heap_create` / `heap_destroy` / `heap_swap`**
- `heap_create(cap)` 分配 `MinHeap` 和 `data` 数组。
- `heap_destroy` 释放堆本身及其 `data` 数组（注意不释放 `HNode` 节点）。
- `heap_swap` 用于交换堆数组中的两个 `HNode*`。

**`heap_push`**
- 将节点插入堆：若容量不足用 `realloc` 扩容；放到数组末尾后执行「上浮」保持最小堆性质（父节点频率 ≤ 子节点频率）。
- 注意：若 `realloc` 失败，函数直接返回（调用方应对内存失败有策略）。

**`heap_pop`**
- 弹出堆顶（最小频率节点），将末尾元素移到顶部并执行「下沉」操作恢复堆序，返回弹出的节点指针。

**`build_huffman`**
- 输入：长度为 256 的 `freq` 频率表。
- 过程：把所有频率 > 0 的字节作为叶子节点推入最小堆；若堆大小为 1 直接返回该节点；否则每次弹出两个最小节点，合并为新父节点并入堆，直到只剩下根节点为止。
- 返回值：哈夫曼树根指针（调用者负责释放树）。

**编码表生成：`codes` 与 `gen_codes`**
- 全局 `char *codes[256]` 保存每个字节对应的编码字符串（'0'/'1'，以 '\0' 结尾）。
- `gen_codes` 递归遍历树，用 `buf` 保存路径（左='0'，右='1'），到达叶子复制路径作为该字节的编码。

**`free_tree`**
- 递归释放树上所有节点内存。

**位操作器：`BitWriter` / `BitReader`**
- `BitWriter` 将位按低位优先写入缓冲字节，满 8 位写出一个字节；`bw_flush` 将残余位写出。
- `BitReader` 按位读取，遇 EOF 返回 -1。实现同样采用低位优先（LSB-first）。

**`compress_file`（压缩流程）**
- 两遍算法：第一遍按块读取统计频率（节省内存）；第二遍重新读取并把每个字节替换为对应的比特串写入输出。
- 头部格式：4 字节魔数 + 8 字节原始长度（uint64_t）+ 256 × uint64_t 频率表（本实现按主机本地字节序写入）。
- 单符号特殊处理：若树只有单一叶子，编码可能为空串，编码阶段会写入至少一位来保证可解码。
- 完成后释放树与编码表。

**`decompress_file`（解压流程）**
- 读取魔数、原始长度、频率表；根据频率表重建哈夫曼树。
- 若树为空（原始为空文件）创建空输出。
- 若树只有一个符号，直接写 `orig_size` 次该符号并返回。
- 否则按位读取并沿树遍历，到达叶子则写出字符，重复直到写出 `orig_size` 字节。

**`main`**
- 支持 `-c`（压缩）和 `-d`（解压）。当前源码中 `-s`（统计打印）尚未实现（原仓库中曾有相关片段被误插入并已移除），如需我可恢复并实现该选项。

**注意事项与改进建议**
- 字节序：头部中写入的 `orig_size` 和 `freq` 使用的是主机字节序，跨不同字节序机器互通时需要统一（建议使用固定的 little-endian 或 big-endian 写入/读取）。
- 头部大小：当前频率表为 256×8=2048 字节，对于小文件头会很大。优化建议：只写出现的符号和计数（使用符号个数+对列表编码）以节省空间。
- 内存失败处理：`realloc` 失败时当前实现直接返回（丢弃插入），可以改为向调用者返回错误并中止操作以避免半完成状态。

**下一步（可选）**
- 我可以为你：
  - 恢复并实现 `-s` 统计选项（打印频率、概率及可打印字符表示），并在 `main` 中支持该参数。
  - 把头部数值改为固定字节序（例如小端），以保证跨平台兼容。
  - 将频率表压缩为“出现符号列表”以减少头部体积。

如需我把其中一个选项实现并提交修改，请回复你想要的功能（例如 `实现 -s` 或 `统一字节序为 little-endian`），我会继续修改并在完成后运行回环测试。

*** 文件已写入： `数据结构/哈夫曼编码解码说明.md` ***
